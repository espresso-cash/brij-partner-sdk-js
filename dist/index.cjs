'use strict';

var jose = require('jose');
var axios = require('axios');
var nacl = require('tweetnacl');
var base58 = require('bs58');
var naclUtil = require('tweetnacl-util');
var ed2curve = require('ed2curve');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var axios__default = /*#__PURE__*/_interopDefault(axios);
var nacl__default = /*#__PURE__*/_interopDefault(nacl);
var base58__default = /*#__PURE__*/_interopDefault(base58);
var naclUtil__default = /*#__PURE__*/_interopDefault(naclUtil);
var ed2curve__default = /*#__PURE__*/_interopDefault(ed2curve);

// Copyright 2008 Google Inc.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Code generated by the Protocol Buffer compiler is owned by the owner
// of the input file used when generating it.  This code is not
// standalone and requires a support library to be linked with it.  This
// support library is itself covered by the above license.
/* eslint-disable prefer-const,@typescript-eslint/restrict-plus-operands */
/**
 * Read a 64 bit varint as two JS numbers.
 *
 * Returns tuple:
 * [0]: low bits
 * [1]: high bits
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175
 */
function varint64read() {
    let lowBits = 0;
    let highBits = 0;
    for (let shift = 0; shift < 28; shift += 7) {
        let b = this.buf[this.pos++];
        lowBits |= (b & 0x7f) << shift;
        if ((b & 0x80) == 0) {
            this.assertBounds();
            return [lowBits, highBits];
        }
    }
    let middleByte = this.buf[this.pos++];
    // last four bits of the first 32 bit number
    lowBits |= (middleByte & 0x0f) << 28;
    // 3 upper bits are part of the next 32 bit number
    highBits = (middleByte & 0x70) >> 4;
    if ((middleByte & 0x80) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
    }
    for (let shift = 3; shift <= 31; shift += 7) {
        let b = this.buf[this.pos++];
        highBits |= (b & 0x7f) << shift;
        if ((b & 0x80) == 0) {
            this.assertBounds();
            return [lowBits, highBits];
        }
    }
    throw new Error("invalid varint");
}
/**
 * Write a 64 bit varint, given as two JS numbers, to the given bytes array.
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344
 */
function varint64write(lo, hi, bytes) {
    for (let i = 0; i < 28; i = i + 7) {
        const shift = lo >>> i;
        const hasNext = !(shift >>> 7 == 0 && hi == 0);
        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;
        bytes.push(byte);
        if (!hasNext) {
            return;
        }
    }
    const splitBits = ((lo >>> 28) & 0x0f) | ((hi & 0x07) << 4);
    const hasMoreBits = !(hi >> 3 == 0);
    bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xff);
    if (!hasMoreBits) {
        return;
    }
    for (let i = 3; i < 31; i = i + 7) {
        const shift = hi >>> i;
        const hasNext = !(shift >>> 7 == 0);
        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;
        bytes.push(byte);
        if (!hasNext) {
            return;
        }
    }
    bytes.push((hi >>> 31) & 0x01);
}
// constants for binary math
const TWO_PWR_32_DBL = 0x100000000;
/**
 * Parse decimal string of 64 bit integer value as two JS numbers.
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10
 */
function int64FromString(dec) {
    // Check for minus sign.
    const minus = dec[0] === "-";
    if (minus) {
        dec = dec.slice(1);
    }
    // Work 6 decimal digits at a time, acting like we're converting base 1e6
    // digits to binary. This is safe to do with floating point math because
    // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.
    const base = 1e6;
    let lowBits = 0;
    let highBits = 0;
    function add1e6digit(begin, end) {
        // Note: Number('') is 0.
        const digit1e6 = Number(dec.slice(begin, end));
        highBits *= base;
        lowBits = lowBits * base + digit1e6;
        // Carry bits from lowBits to
        if (lowBits >= TWO_PWR_32_DBL) {
            highBits = highBits + ((lowBits / TWO_PWR_32_DBL) | 0);
            lowBits = lowBits % TWO_PWR_32_DBL;
        }
    }
    add1e6digit(-24, -18);
    add1e6digit(-18, -12);
    add1e6digit(-12, -6);
    add1e6digit(-6);
    return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
}
/**
 * Losslessly converts a 64-bit signed integer in 32:32 split representation
 * into a decimal string.
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10
 */
function int64ToString(lo, hi) {
    let bits = newBits(lo, hi);
    // If we're treating the input as a signed value and the high bit is set, do
    // a manual two's complement conversion before the decimal conversion.
    const negative = bits.hi & 0x80000000;
    if (negative) {
        bits = negate(bits.lo, bits.hi);
    }
    const result = uInt64ToString(bits.lo, bits.hi);
    return negative ? "-" + result : result;
}
/**
 * Losslessly converts a 64-bit unsigned integer in 32:32 split representation
 * into a decimal string.
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10
 */
function uInt64ToString(lo, hi) {
    ({ lo, hi } = toUnsigned(lo, hi));
    // Skip the expensive conversion if the number is small enough to use the
    // built-in conversions.
    // Number.MAX_SAFE_INTEGER = 0x001FFFFF FFFFFFFF, thus any number with
    // highBits <= 0x1FFFFF can be safely expressed with a double and retain
    // integer precision.
    // Proven by: Number.isSafeInteger(0x1FFFFF * 2**32 + 0xFFFFFFFF) == true.
    if (hi <= 0x1fffff) {
        return String(TWO_PWR_32_DBL * hi + lo);
    }
    // What this code is doing is essentially converting the input number from
    // base-2 to base-1e7, which allows us to represent the 64-bit range with
    // only 3 (very large) digits. Those digits are then trivial to convert to
    // a base-10 string.
    // The magic numbers used here are -
    // 2^24 = 16777216 = (1,6777216) in base-1e7.
    // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.
    // Split 32:32 representation into 16:24:24 representation so our
    // intermediate digits don't overflow.
    const low = lo & 0xffffff;
    const mid = ((lo >>> 24) | (hi << 8)) & 0xffffff;
    const high = (hi >> 16) & 0xffff;
    // Assemble our three base-1e7 digits, ignoring carries. The maximum
    // value in a digit at this step is representable as a 48-bit integer, which
    // can be stored in a 64-bit floating point number.
    let digitA = low + mid * 6777216 + high * 6710656;
    let digitB = mid + high * 8147497;
    let digitC = high * 2;
    // Apply carries from A to B and from B to C.
    const base = 10000000;
    if (digitA >= base) {
        digitB += Math.floor(digitA / base);
        digitA %= base;
    }
    if (digitB >= base) {
        digitC += Math.floor(digitB / base);
        digitB %= base;
    }
    // If digitC is 0, then we should have returned in the trivial code path
    // at the top for non-safe integers. Given this, we can assume both digitB
    // and digitA need leading zeros.
    return (digitC.toString() +
        decimalFrom1e7WithLeadingZeros(digitB) +
        decimalFrom1e7WithLeadingZeros(digitA));
}
function toUnsigned(lo, hi) {
    return { lo: lo >>> 0, hi: hi >>> 0 };
}
function newBits(lo, hi) {
    return { lo: lo | 0, hi: hi | 0 };
}
/**
 * Returns two's compliment negation of input.
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Signed_32-bit_integers
 */
function negate(lowBits, highBits) {
    highBits = ~highBits;
    if (lowBits) {
        lowBits = ~lowBits + 1;
    }
    else {
        // If lowBits is 0, then bitwise-not is 0xFFFFFFFF,
        // adding 1 to that, results in 0x100000000, which leaves
        // the low bits 0x0 and simply adds one to the high bits.
        highBits += 1;
    }
    return newBits(lowBits, highBits);
}
/**
 * Returns decimal representation of digit1e7 with leading zeros.
 */
const decimalFrom1e7WithLeadingZeros = (digit1e7) => {
    const partial = String(digit1e7);
    return "0000000".slice(partial.length) + partial;
};
/**
 * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144
 */
function varint32write(value, bytes) {
    if (value >= 0) {
        // write value as varint 32
        while (value > 0x7f) {
            bytes.push((value & 0x7f) | 0x80);
            value = value >>> 7;
        }
        bytes.push(value);
    }
    else {
        for (let i = 0; i < 9; i++) {
            bytes.push((value & 127) | 128);
            value = value >> 7;
        }
        bytes.push(1);
    }
}
/**
 * Read an unsigned 32 bit varint.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220
 */
function varint32read() {
    let b = this.buf[this.pos++];
    let result = b & 0x7f;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7f) << 7;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7f) << 14;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7f) << 21;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    // Extract only last 4 bits
    b = this.buf[this.pos++];
    result |= (b & 0x0f) << 28;
    for (let readBytes = 5; (b & 0x80) !== 0 && readBytes < 10; readBytes++)
        b = this.buf[this.pos++];
    if ((b & 0x80) != 0)
        throw new Error("invalid varint");
    this.assertBounds();
    // Result can have 32 bits, convert it to unsigned
    return result >>> 0;
}

// Copyright 2021-2024 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * Int64Support for the current environment.
 */
const protoInt64 = /*@__PURE__*/ makeInt64Support();
function makeInt64Support() {
    const dv = new DataView(new ArrayBuffer(8));
    // note that Safari 14 implements BigInt, but not the DataView methods
    const ok = typeof BigInt === "function" &&
        typeof dv.getBigInt64 === "function" &&
        typeof dv.getBigUint64 === "function" &&
        typeof dv.setBigInt64 === "function" &&
        typeof dv.setBigUint64 === "function" &&
        (typeof process != "object" ||
            typeof process.env != "object" ||
            process.env.BUF_BIGINT_DISABLE !== "1");
    if (ok) {
        const MIN = BigInt("-9223372036854775808"), MAX = BigInt("9223372036854775807"), UMIN = BigInt("0"), UMAX = BigInt("18446744073709551615");
        return {
            zero: BigInt(0),
            supported: true,
            parse(value) {
                const bi = typeof value == "bigint" ? value : BigInt(value);
                if (bi > MAX || bi < MIN) {
                    throw new Error(`invalid int64: ${value}`);
                }
                return bi;
            },
            uParse(value) {
                const bi = typeof value == "bigint" ? value : BigInt(value);
                if (bi > UMAX || bi < UMIN) {
                    throw new Error(`invalid uint64: ${value}`);
                }
                return bi;
            },
            enc(value) {
                dv.setBigInt64(0, this.parse(value), true);
                return {
                    lo: dv.getInt32(0, true),
                    hi: dv.getInt32(4, true),
                };
            },
            uEnc(value) {
                dv.setBigInt64(0, this.uParse(value), true);
                return {
                    lo: dv.getInt32(0, true),
                    hi: dv.getInt32(4, true),
                };
            },
            dec(lo, hi) {
                dv.setInt32(0, lo, true);
                dv.setInt32(4, hi, true);
                return dv.getBigInt64(0, true);
            },
            uDec(lo, hi) {
                dv.setInt32(0, lo, true);
                dv.setInt32(4, hi, true);
                return dv.getBigUint64(0, true);
            },
        };
    }
    return {
        zero: "0",
        supported: false,
        parse(value) {
            if (typeof value != "string") {
                value = value.toString();
            }
            assertInt64String(value);
            return value;
        },
        uParse(value) {
            if (typeof value != "string") {
                value = value.toString();
            }
            assertUInt64String(value);
            return value;
        },
        enc(value) {
            if (typeof value != "string") {
                value = value.toString();
            }
            assertInt64String(value);
            return int64FromString(value);
        },
        uEnc(value) {
            if (typeof value != "string") {
                value = value.toString();
            }
            assertUInt64String(value);
            return int64FromString(value);
        },
        dec(lo, hi) {
            return int64ToString(lo, hi);
        },
        uDec(lo, hi) {
            return uInt64ToString(lo, hi);
        },
    };
}
function assertInt64String(value) {
    if (!/^-?[0-9]+$/.test(value)) {
        throw new Error("invalid int64: " + value);
    }
}
function assertUInt64String(value) {
    if (!/^[0-9]+$/.test(value)) {
        throw new Error("invalid uint64: " + value);
    }
}

// Copyright 2021-2024 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
const symbol = Symbol.for("@bufbuild/protobuf/text-encoding");
function getTextEncoding() {
    if (globalThis[symbol] == undefined) {
        const te = new globalThis.TextEncoder();
        const td = new globalThis.TextDecoder();
        globalThis[symbol] = {
            encodeUtf8(text) {
                return te.encode(text);
            },
            decodeUtf8(bytes) {
                return td.decode(bytes);
            },
            checkUtf8(text) {
                try {
                    encodeURIComponent(text);
                    return true;
                }
                catch (e) {
                    return false;
                }
            },
        };
    }
    return globalThis[symbol];
}

// Copyright 2021-2024 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/* eslint-disable prefer-const,no-case-declarations,@typescript-eslint/restrict-plus-operands */
/**
 * Protobuf binary format wire types.
 *
 * A wire type provides just enough information to find the length of the
 * following value.
 *
 * See https://developers.google.com/protocol-buffers/docs/encoding#structure
 */
var WireType;
(function (WireType) {
    /**
     * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum
     */
    WireType[WireType["Varint"] = 0] = "Varint";
    /**
     * Used for fixed64, sfixed64, double.
     * Always 8 bytes with little-endian byte order.
     */
    WireType[WireType["Bit64"] = 1] = "Bit64";
    /**
     * Used for string, bytes, embedded messages, packed repeated fields
     *
     * Only repeated numeric types (types which use the varint, 32-bit,
     * or 64-bit wire types) can be packed. In proto3, such fields are
     * packed by default.
     */
    WireType[WireType["LengthDelimited"] = 2] = "LengthDelimited";
    /**
     * Start of a tag-delimited aggregate, such as a proto2 group, or a message
     * in editions with message_encoding = DELIMITED.
     */
    WireType[WireType["StartGroup"] = 3] = "StartGroup";
    /**
     * End of a tag-delimited aggregate.
     */
    WireType[WireType["EndGroup"] = 4] = "EndGroup";
    /**
     * Used for fixed32, sfixed32, float.
     * Always 4 bytes with little-endian byte order.
     */
    WireType[WireType["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));
/**
 * Maximum value for a 32-bit floating point value (Protobuf FLOAT).
 */
const FLOAT32_MAX = 3.4028234663852886e38;
/**
 * Minimum value for a 32-bit floating point value (Protobuf FLOAT).
 */
const FLOAT32_MIN = -34028234663852886e22;
/**
 * Maximum value for an unsigned 32-bit integer (Protobuf UINT32, FIXED32).
 */
const UINT32_MAX = 0xffffffff;
/**
 * Maximum value for a signed 32-bit integer (Protobuf INT32, SFIXED32, SINT32).
 */
const INT32_MAX = 0x7fffffff;
/**
 * Minimum value for a signed 32-bit integer (Protobuf INT32, SFIXED32, SINT32).
 */
const INT32_MIN = -2147483648;
class BinaryWriter {
    constructor(encodeUtf8 = getTextEncoding().encodeUtf8) {
        this.encodeUtf8 = encodeUtf8;
        /**
         * Previous fork states.
         */
        this.stack = [];
        this.chunks = [];
        this.buf = [];
    }
    /**
     * Return all bytes written and reset this writer.
     */
    finish() {
        if (this.buf.length) {
            this.chunks.push(new Uint8Array(this.buf)); // flush the buffer
            this.buf = [];
        }
        let len = 0;
        for (let i = 0; i < this.chunks.length; i++)
            len += this.chunks[i].length;
        let bytes = new Uint8Array(len);
        let offset = 0;
        for (let i = 0; i < this.chunks.length; i++) {
            bytes.set(this.chunks[i], offset);
            offset += this.chunks[i].length;
        }
        this.chunks = [];
        return bytes;
    }
    /**
     * Start a new fork for length-delimited data like a message
     * or a packed repeated field.
     *
     * Must be joined later with `join()`.
     */
    fork() {
        this.stack.push({ chunks: this.chunks, buf: this.buf });
        this.chunks = [];
        this.buf = [];
        return this;
    }
    /**
     * Join the last fork. Write its length and bytes, then
     * return to the previous state.
     */
    join() {
        // get chunk of fork
        let chunk = this.finish();
        // restore previous state
        let prev = this.stack.pop();
        if (!prev)
            throw new Error("invalid state, fork stack empty");
        this.chunks = prev.chunks;
        this.buf = prev.buf;
        // write length of chunk as varint
        this.uint32(chunk.byteLength);
        return this.raw(chunk);
    }
    /**
     * Writes a tag (field number and wire type).
     *
     * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
     *
     * Generated code should compute the tag ahead of time and call `uint32()`.
     */
    tag(fieldNo, type) {
        return this.uint32(((fieldNo << 3) | type) >>> 0);
    }
    /**
     * Write a chunk of raw bytes.
     */
    raw(chunk) {
        if (this.buf.length) {
            this.chunks.push(new Uint8Array(this.buf));
            this.buf = [];
        }
        this.chunks.push(chunk);
        return this;
    }
    /**
     * Write a `uint32` value, an unsigned 32 bit varint.
     */
    uint32(value) {
        assertUInt32(value);
        // write value as varint 32, inlined for speed
        while (value > 0x7f) {
            this.buf.push((value & 0x7f) | 0x80);
            value = value >>> 7;
        }
        this.buf.push(value);
        return this;
    }
    /**
     * Write a `int32` value, a signed 32 bit varint.
     */
    int32(value) {
        assertInt32(value);
        varint32write(value, this.buf);
        return this;
    }
    /**
     * Write a `bool` value, a variant.
     */
    bool(value) {
        this.buf.push(value ? 1 : 0);
        return this;
    }
    /**
     * Write a `bytes` value, length-delimited arbitrary data.
     */
    bytes(value) {
        this.uint32(value.byteLength); // write length of chunk as varint
        return this.raw(value);
    }
    /**
     * Write a `string` value, length-delimited data converted to UTF-8 text.
     */
    string(value) {
        let chunk = this.encodeUtf8(value);
        this.uint32(chunk.byteLength); // write length of chunk as varint
        return this.raw(chunk);
    }
    /**
     * Write a `float` value, 32-bit floating point number.
     */
    float(value) {
        assertFloat32(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setFloat32(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `double` value, a 64-bit floating point number.
     */
    double(value) {
        let chunk = new Uint8Array(8);
        new DataView(chunk.buffer).setFloat64(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
     */
    fixed32(value) {
        assertUInt32(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setUint32(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
     */
    sfixed32(value) {
        assertInt32(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setInt32(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
     */
    sint32(value) {
        assertInt32(value);
        // zigzag encode
        value = ((value << 1) ^ (value >> 31)) >>> 0;
        varint32write(value, this.buf);
        return this;
    }
    /**
     * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
     */
    sfixed64(value) {
        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);
        view.setInt32(0, tc.lo, true);
        view.setInt32(4, tc.hi, true);
        return this.raw(chunk);
    }
    /**
     * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
     */
    fixed64(value) {
        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);
        view.setInt32(0, tc.lo, true);
        view.setInt32(4, tc.hi, true);
        return this.raw(chunk);
    }
    /**
     * Write a `int64` value, a signed 64-bit varint.
     */
    int64(value) {
        let tc = protoInt64.enc(value);
        varint64write(tc.lo, tc.hi, this.buf);
        return this;
    }
    /**
     * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64(value) {
        let tc = protoInt64.enc(value), 
        // zigzag encode
        sign = tc.hi >> 31, lo = (tc.lo << 1) ^ sign, hi = ((tc.hi << 1) | (tc.lo >>> 31)) ^ sign;
        varint64write(lo, hi, this.buf);
        return this;
    }
    /**
     * Write a `uint64` value, an unsigned 64-bit varint.
     */
    uint64(value) {
        let tc = protoInt64.uEnc(value);
        varint64write(tc.lo, tc.hi, this.buf);
        return this;
    }
}
class BinaryReader {
    constructor(buf, decodeUtf8 = getTextEncoding().decodeUtf8) {
        this.decodeUtf8 = decodeUtf8;
        this.varint64 = varint64read; // dirty cast for `this`
        /**
         * Read a `uint32` field, an unsigned 32 bit varint.
         */
        this.uint32 = varint32read;
        this.buf = buf;
        this.len = buf.length;
        this.pos = 0;
        this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    }
    /**
     * Reads a tag - field number and wire type.
     */
    tag() {
        let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
        if (fieldNo <= 0 || wireType < 0 || wireType > 5)
            throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
        return [fieldNo, wireType];
    }
    /**
     * Skip one element and return the skipped data.
     *
     * When skipping StartGroup, provide the tags field number to check for
     * matching field number in the EndGroup tag.
     */
    skip(wireType, fieldNo) {
        let start = this.pos;
        switch (wireType) {
            case WireType.Varint:
                while (this.buf[this.pos++] & 0x80) {
                    // ignore
                }
                break;
            // eslint-disable-next-line
            // @ts-expect-error TS7029: Fallthrough case in switch
            case WireType.Bit64:
                this.pos += 4;
            // eslint-disable-next-line no-fallthrough
            case WireType.Bit32:
                this.pos += 4;
                break;
            case WireType.LengthDelimited:
                let len = this.uint32();
                this.pos += len;
                break;
            case WireType.StartGroup:
                for (;;) {
                    const [fn, wt] = this.tag();
                    if (wt === WireType.EndGroup) {
                        if (fieldNo !== undefined && fn !== fieldNo) {
                            throw new Error("invalid end group tag");
                        }
                        break;
                    }
                    this.skip(wt, fn);
                }
                break;
            default:
                throw new Error("cant skip wire type " + wireType);
        }
        this.assertBounds();
        return this.buf.subarray(start, this.pos);
    }
    /**
     * Throws error if position in byte array is out of range.
     */
    assertBounds() {
        if (this.pos > this.len)
            throw new RangeError("premature EOF");
    }
    /**
     * Read a `int32` field, a signed 32 bit varint.
     */
    int32() {
        return this.uint32() | 0;
    }
    /**
     * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
     */
    sint32() {
        let zze = this.uint32();
        // decode zigzag
        return (zze >>> 1) ^ -(zze & 1);
    }
    /**
     * Read a `int64` field, a signed 64-bit varint.
     */
    int64() {
        return protoInt64.dec(...this.varint64());
    }
    /**
     * Read a `uint64` field, an unsigned 64-bit varint.
     */
    uint64() {
        return protoInt64.uDec(...this.varint64());
    }
    /**
     * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64() {
        let [lo, hi] = this.varint64();
        // decode zig zag
        let s = -(lo & 1);
        lo = ((lo >>> 1) | ((hi & 1) << 31)) ^ s;
        hi = (hi >>> 1) ^ s;
        return protoInt64.dec(lo, hi);
    }
    /**
     * Read a `bool` field, a variant.
     */
    bool() {
        let [lo, hi] = this.varint64();
        return lo !== 0 || hi !== 0;
    }
    /**
     * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
     */
    fixed32() {
        return this.view.getUint32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
     */
    sfixed32() {
        return this.view.getInt32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
     */
    fixed64() {
        return protoInt64.uDec(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
     */
    sfixed64() {
        return protoInt64.dec(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `float` field, 32-bit floating point number.
     */
    float() {
        return this.view.getFloat32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `double` field, a 64-bit floating point number.
     */
    double() {
        return this.view.getFloat64((this.pos += 8) - 8, true);
    }
    /**
     * Read a `bytes` field, length-delimited arbitrary data.
     */
    bytes() {
        let len = this.uint32(), start = this.pos;
        this.pos += len;
        this.assertBounds();
        return this.buf.subarray(start, start + len);
    }
    /**
     * Read a `string` field, length-delimited data converted to UTF-8 text.
     */
    string() {
        return this.decodeUtf8(this.bytes());
    }
}
/**
 * Assert a valid signed protobuf 32-bit integer as a number or string.
 */
function assertInt32(arg) {
    if (typeof arg == "string") {
        arg = Number(arg);
    }
    else if (typeof arg != "number") {
        throw new Error("invalid int32: " + typeof arg);
    }
    if (!Number.isInteger(arg) ||
        arg > INT32_MAX ||
        arg < INT32_MIN)
        throw new Error("invalid int32: " + arg);
}
/**
 * Assert a valid unsigned protobuf 32-bit integer as a number or string.
 */
function assertUInt32(arg) {
    if (typeof arg == "string") {
        arg = Number(arg);
    }
    else if (typeof arg != "number") {
        throw new Error("invalid uint32: " + typeof arg);
    }
    if (!Number.isInteger(arg) ||
        arg > UINT32_MAX ||
        arg < 0)
        throw new Error("invalid uint32: " + arg);
}
/**
 * Assert a valid protobuf float value as a number or string.
 */
function assertFloat32(arg) {
    if (typeof arg == "string") {
        const o = arg;
        arg = Number(arg);
        if (isNaN(arg) && o !== "NaN") {
            throw new Error("invalid float32: " + o);
        }
    }
    else if (typeof arg != "number") {
        throw new Error("invalid float32: " + typeof arg);
    }
    if (Number.isFinite(arg) &&
        (arg > FLOAT32_MAX || arg < FLOAT32_MIN))
        throw new Error("invalid float32: " + arg);
}

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.4
//   protoc               v5.29.3
// source: google/protobuf/timestamp.proto
/* eslint-disable */
function createBaseTimestamp() {
    return { seconds: 0, nanos: 0 };
}
const Timestamp = {
    encode(message, writer = new BinaryWriter()) {
        if (message.seconds !== 0) {
            writer.uint32(8).int64(message.seconds);
        }
        if (message.nanos !== 0) {
            writer.uint32(16).int32(message.nanos);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTimestamp();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.seconds = longToNumber(reader.int64());
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.nanos = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            seconds: isSet$2(object.seconds) ? globalThis.Number(object.seconds) : 0,
            nanos: isSet$2(object.nanos) ? globalThis.Number(object.nanos) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.seconds !== 0) {
            obj.seconds = Math.round(message.seconds);
        }
        if (message.nanos !== 0) {
            obj.nanos = Math.round(message.nanos);
        }
        return obj;
    },
    create(base) {
        return Timestamp.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTimestamp();
        message.seconds = object.seconds ?? 0;
        message.nanos = object.nanos ?? 0;
        return message;
    },
};
function longToNumber(int64) {
    const num = globalThis.Number(int64.toString());
    if (num > globalThis.Number.MAX_SAFE_INTEGER) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    if (num < globalThis.Number.MIN_SAFE_INTEGER) {
        throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
    }
    return num;
}
function isSet$2(value) {
    return value !== null && value !== undefined;
}

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.4
//   protoc               v5.29.3
// source: protos/data.proto
/* eslint-disable */
var DataType;
(function (DataType) {
    DataType[DataType["DATA_TYPE_UNSPECIFIED"] = 0] = "DATA_TYPE_UNSPECIFIED";
    DataType[DataType["DATA_TYPE_PHONE"] = 1] = "DATA_TYPE_PHONE";
    DataType[DataType["DATA_TYPE_EMAIL"] = 2] = "DATA_TYPE_EMAIL";
    DataType[DataType["DATA_TYPE_NAME"] = 3] = "DATA_TYPE_NAME";
    DataType[DataType["DATA_TYPE_BIRTH_DATE"] = 4] = "DATA_TYPE_BIRTH_DATE";
    DataType[DataType["DATA_TYPE_DOCUMENT"] = 5] = "DATA_TYPE_DOCUMENT";
    DataType[DataType["DATA_TYPE_BANK_INFO"] = 6] = "DATA_TYPE_BANK_INFO";
    DataType[DataType["DATA_TYPE_SELFIE_IMAGE"] = 7] = "DATA_TYPE_SELFIE_IMAGE";
    DataType[DataType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DataType || (DataType = {}));
function dataTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "DATA_TYPE_UNSPECIFIED":
            return DataType.DATA_TYPE_UNSPECIFIED;
        case 1:
        case "DATA_TYPE_PHONE":
            return DataType.DATA_TYPE_PHONE;
        case 2:
        case "DATA_TYPE_EMAIL":
            return DataType.DATA_TYPE_EMAIL;
        case 3:
        case "DATA_TYPE_NAME":
            return DataType.DATA_TYPE_NAME;
        case 4:
        case "DATA_TYPE_BIRTH_DATE":
            return DataType.DATA_TYPE_BIRTH_DATE;
        case 5:
        case "DATA_TYPE_DOCUMENT":
            return DataType.DATA_TYPE_DOCUMENT;
        case 6:
        case "DATA_TYPE_BANK_INFO":
            return DataType.DATA_TYPE_BANK_INFO;
        case 7:
        case "DATA_TYPE_SELFIE_IMAGE":
            return DataType.DATA_TYPE_SELFIE_IMAGE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return DataType.UNRECOGNIZED;
    }
}
var DocumentType;
(function (DocumentType) {
    DocumentType[DocumentType["DOCUMENT_TYPE_UNSPECIFIED"] = 0] = "DOCUMENT_TYPE_UNSPECIFIED";
    DocumentType[DocumentType["DOCUMENT_TYPE_VOTER_ID"] = 1] = "DOCUMENT_TYPE_VOTER_ID";
    DocumentType[DocumentType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DocumentType || (DocumentType = {}));
function documentTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "DOCUMENT_TYPE_UNSPECIFIED":
            return DocumentType.DOCUMENT_TYPE_UNSPECIFIED;
        case 1:
        case "DOCUMENT_TYPE_VOTER_ID":
            return DocumentType.DOCUMENT_TYPE_VOTER_ID;
        case -1:
        case "UNRECOGNIZED":
        default:
            return DocumentType.UNRECOGNIZED;
    }
}
function documentTypeToJSON(object) {
    switch (object) {
        case DocumentType.DOCUMENT_TYPE_UNSPECIFIED:
            return "DOCUMENT_TYPE_UNSPECIFIED";
        case DocumentType.DOCUMENT_TYPE_VOTER_ID:
            return "DOCUMENT_TYPE_VOTER_ID";
        case DocumentType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseName() {
    return { firstName: "", lastName: "" };
}
const Name = {
    encode(message, writer = new BinaryWriter()) {
        if (message.firstName !== "") {
            writer.uint32(10).string(message.firstName);
        }
        if (message.lastName !== "") {
            writer.uint32(18).string(message.lastName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseName();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.firstName = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.lastName = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            firstName: isSet$1(object.firstName) ? globalThis.String(object.firstName) : "",
            lastName: isSet$1(object.lastName) ? globalThis.String(object.lastName) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.firstName !== "") {
            obj.firstName = message.firstName;
        }
        if (message.lastName !== "") {
            obj.lastName = message.lastName;
        }
        return obj;
    },
    create(base) {
        return Name.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseName();
        message.firstName = object.firstName ?? "";
        message.lastName = object.lastName ?? "";
        return message;
    },
};
function createBaseBirthDate() {
    return { value: undefined };
}
const BirthDate = {
    encode(message, writer = new BinaryWriter()) {
        if (message.value !== undefined) {
            Timestamp.encode(toTimestamp(message.value), writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBirthDate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.value = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { value: isSet$1(object.value) ? fromJsonTimestamp(object.value) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.value !== undefined) {
            obj.value = message.value.toISOString();
        }
        return obj;
    },
    create(base) {
        return BirthDate.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBirthDate();
        message.value = object.value ?? undefined;
        return message;
    },
};
function createBaseDocument() {
    return { type: 0, number: "", countryCode: "" };
}
const Document = {
    encode(message, writer = new BinaryWriter()) {
        if (message.type !== 0) {
            writer.uint32(8).int32(message.type);
        }
        if (message.number !== "") {
            writer.uint32(18).string(message.number);
        }
        if (message.countryCode !== "") {
            writer.uint32(26).string(message.countryCode);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDocument();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.type = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.number = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.countryCode = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet$1(object.type) ? documentTypeFromJSON(object.type) : 0,
            number: isSet$1(object.number) ? globalThis.String(object.number) : "",
            countryCode: isSet$1(object.countryCode) ? globalThis.String(object.countryCode) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.type !== 0) {
            obj.type = documentTypeToJSON(message.type);
        }
        if (message.number !== "") {
            obj.number = message.number;
        }
        if (message.countryCode !== "") {
            obj.countryCode = message.countryCode;
        }
        return obj;
    },
    create(base) {
        return Document.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDocument();
        message.type = object.type ?? 0;
        message.number = object.number ?? "";
        message.countryCode = object.countryCode ?? "";
        return message;
    },
};
function createBaseBankInfo() {
    return { accountNumber: "", bankCode: "", bankName: "" };
}
const BankInfo = {
    encode(message, writer = new BinaryWriter()) {
        if (message.accountNumber !== "") {
            writer.uint32(10).string(message.accountNumber);
        }
        if (message.bankCode !== "") {
            writer.uint32(18).string(message.bankCode);
        }
        if (message.bankName !== "") {
            writer.uint32(26).string(message.bankName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBankInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.accountNumber = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.bankCode = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.bankName = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            accountNumber: isSet$1(object.accountNumber) ? globalThis.String(object.accountNumber) : "",
            bankCode: isSet$1(object.bankCode) ? globalThis.String(object.bankCode) : "",
            bankName: isSet$1(object.bankName) ? globalThis.String(object.bankName) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.accountNumber !== "") {
            obj.accountNumber = message.accountNumber;
        }
        if (message.bankCode !== "") {
            obj.bankCode = message.bankCode;
        }
        if (message.bankName !== "") {
            obj.bankName = message.bankName;
        }
        return obj;
    },
    create(base) {
        return BankInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBankInfo();
        message.accountNumber = object.accountNumber ?? "";
        message.bankCode = object.bankCode ?? "";
        message.bankName = object.bankName ?? "";
        return message;
    },
};
function createBaseEmail() {
    return { value: "" };
}
const Email = {
    encode(message, writer = new BinaryWriter()) {
        if (message.value !== "") {
            writer.uint32(10).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEmail();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { value: isSet$1(object.value) ? globalThis.String(object.value) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return Email.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseEmail();
        message.value = object.value ?? "";
        return message;
    },
};
function createBaseSelfieImage() {
    return { value: new Uint8Array(0) };
}
const SelfieImage = {
    encode(message, writer = new BinaryWriter()) {
        if (message.value.length !== 0) {
            writer.uint32(10).bytes(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSelfieImage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.value = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { value: isSet$1(object.value) ? bytesFromBase64$1(object.value) : new Uint8Array(0) };
    },
    toJSON(message) {
        const obj = {};
        if (message.value.length !== 0) {
            obj.value = base64FromBytes$1(message.value);
        }
        return obj;
    },
    create(base) {
        return SelfieImage.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSelfieImage();
        message.value = object.value ?? new Uint8Array(0);
        return message;
    },
};
function createBasePhone() {
    return { value: "" };
}
const Phone = {
    encode(message, writer = new BinaryWriter()) {
        if (message.value !== "") {
            writer.uint32(10).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePhone();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { value: isSet$1(object.value) ? globalThis.String(object.value) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return Phone.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePhone();
        message.value = object.value ?? "";
        return message;
    },
};
function bytesFromBase64$1(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes$1(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function toTimestamp(date) {
    const seconds = Math.trunc(date.getTime() / 1_000);
    const nanos = (date.getTime() % 1_000) * 1_000_000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (t.seconds || 0) * 1_000;
    millis += (t.nanos || 0) / 1_000_000;
    return new globalThis.Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof globalThis.Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new globalThis.Date(o);
    }
    else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}
function isSet$1(value) {
    return value !== null && value !== undefined;
}

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.4
//   protoc               v5.29.3
// source: protos/validation_status.proto
/* eslint-disable */
var ValidationStatus;
(function (ValidationStatus) {
    ValidationStatus[ValidationStatus["VALIDATION_STATUS_UNSPECIFIED"] = 0] = "VALIDATION_STATUS_UNSPECIFIED";
    ValidationStatus[ValidationStatus["VALIDATION_STATUS_PENDING"] = 1] = "VALIDATION_STATUS_PENDING";
    ValidationStatus[ValidationStatus["VALIDATION_STATUS_APPROVED"] = 2] = "VALIDATION_STATUS_APPROVED";
    ValidationStatus[ValidationStatus["VALIDATION_STATUS_REJECTED"] = 3] = "VALIDATION_STATUS_REJECTED";
    ValidationStatus[ValidationStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ValidationStatus || (ValidationStatus = {}));
function validationStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "VALIDATION_STATUS_UNSPECIFIED":
            return ValidationStatus.VALIDATION_STATUS_UNSPECIFIED;
        case 1:
        case "VALIDATION_STATUS_PENDING":
            return ValidationStatus.VALIDATION_STATUS_PENDING;
        case 2:
        case "VALIDATION_STATUS_APPROVED":
            return ValidationStatus.VALIDATION_STATUS_APPROVED;
        case 3:
        case "VALIDATION_STATUS_REJECTED":
            return ValidationStatus.VALIDATION_STATUS_REJECTED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ValidationStatus.UNRECOGNIZED;
    }
}

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.4
//   protoc               v5.29.3
// source: protos/kyc_item.proto
/* eslint-disable */
var KycStatus;
(function (KycStatus) {
    KycStatus[KycStatus["KYC_STATUS_UNSPECIFIED"] = 0] = "KYC_STATUS_UNSPECIFIED";
    KycStatus[KycStatus["KYC_STATUS_PENDING"] = 1] = "KYC_STATUS_PENDING";
    KycStatus[KycStatus["KYC_STATUS_APPROVED"] = 2] = "KYC_STATUS_APPROVED";
    KycStatus[KycStatus["KYC_STATUS_REJECTED"] = 3] = "KYC_STATUS_REJECTED";
    KycStatus[KycStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(KycStatus || (KycStatus = {}));
function kycStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "KYC_STATUS_UNSPECIFIED":
            return KycStatus.KYC_STATUS_UNSPECIFIED;
        case 1:
        case "KYC_STATUS_PENDING":
            return KycStatus.KYC_STATUS_PENDING;
        case 2:
        case "KYC_STATUS_APPROVED":
            return KycStatus.KYC_STATUS_APPROVED;
        case 3:
        case "KYC_STATUS_REJECTED":
            return KycStatus.KYC_STATUS_REJECTED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return KycStatus.UNRECOGNIZED;
    }
}
function kycStatusToJSON(object) {
    switch (object) {
        case KycStatus.KYC_STATUS_UNSPECIFIED:
            return "KYC_STATUS_UNSPECIFIED";
        case KycStatus.KYC_STATUS_PENDING:
            return "KYC_STATUS_PENDING";
        case KycStatus.KYC_STATUS_APPROVED:
            return "KYC_STATUS_APPROVED";
        case KycStatus.KYC_STATUS_REJECTED:
            return "KYC_STATUS_REJECTED";
        case KycStatus.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseKycItem() {
    return { country: "", status: 0, provider: "", userPublicKey: "", hashes: [], additionalData: {} };
}
const KycItem = {
    encode(message, writer = new BinaryWriter()) {
        if (message.country !== "") {
            writer.uint32(10).string(message.country);
        }
        if (message.status !== 0) {
            writer.uint32(16).int32(message.status);
        }
        if (message.provider !== "") {
            writer.uint32(26).string(message.provider);
        }
        if (message.userPublicKey !== "") {
            writer.uint32(34).string(message.userPublicKey);
        }
        for (const v of message.hashes) {
            writer.uint32(42).string(v);
        }
        Object.entries(message.additionalData).forEach(([key, value]) => {
            KycItem_AdditionalDataEntry.encode({ key: key, value }, writer.uint32(50).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseKycItem();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.country = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.status = reader.int32();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.provider = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.userPublicKey = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.hashes.push(reader.string());
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    const entry6 = KycItem_AdditionalDataEntry.decode(reader, reader.uint32());
                    if (entry6.value !== undefined) {
                        message.additionalData[entry6.key] = entry6.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            country: isSet(object.country) ? globalThis.String(object.country) : "",
            status: isSet(object.status) ? kycStatusFromJSON(object.status) : 0,
            provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
            userPublicKey: isSet(object.userPublicKey) ? globalThis.String(object.userPublicKey) : "",
            hashes: globalThis.Array.isArray(object?.hashes) ? object.hashes.map((e) => globalThis.String(e)) : [],
            additionalData: isObject(object.additionalData)
                ? Object.entries(object.additionalData).reduce((acc, [key, value]) => {
                    acc[key] = bytesFromBase64(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.country !== "") {
            obj.country = message.country;
        }
        if (message.status !== 0) {
            obj.status = kycStatusToJSON(message.status);
        }
        if (message.provider !== "") {
            obj.provider = message.provider;
        }
        if (message.userPublicKey !== "") {
            obj.userPublicKey = message.userPublicKey;
        }
        if (message.hashes?.length) {
            obj.hashes = message.hashes;
        }
        if (message.additionalData) {
            const entries = Object.entries(message.additionalData);
            if (entries.length > 0) {
                obj.additionalData = {};
                entries.forEach(([k, v]) => {
                    obj.additionalData[k] = base64FromBytes(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return KycItem.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseKycItem();
        message.country = object.country ?? "";
        message.status = object.status ?? 0;
        message.provider = object.provider ?? "";
        message.userPublicKey = object.userPublicKey ?? "";
        message.hashes = object.hashes?.map((e) => e) || [];
        message.additionalData = Object.entries(object.additionalData ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = value;
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseKycItem_AdditionalDataEntry() {
    return { key: "", value: new Uint8Array(0) };
}
const KycItem_AdditionalDataEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value.length !== 0) {
            writer.uint32(18).bytes(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseKycItem_AdditionalDataEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value.length !== 0) {
            obj.value = base64FromBytes(message.value);
        }
        return obj;
    },
    create(base) {
        return KycItem_AdditionalDataEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseKycItem_AdditionalDataEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? new Uint8Array(0);
        return message;
    },
};
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}

class AppConfig {
    storageBaseUrl;
    orderBaseUrl;
    verifierAuthPk;
    constructor(storageBaseUrl, orderBaseUrl, verifierAuthPk) {
        this.storageBaseUrl = storageBaseUrl;
        this.orderBaseUrl = orderBaseUrl;
        this.verifierAuthPk = verifierAuthPk;
    }
    static demo() {
        return new AppConfig("https://storage-demo.brij.fi/", "https://orders-demo.brij.fi/", "HHV5joB6D4c2pigVZcQ9RY5suDMvAiHBLLBCFqmWuM4E");
    }
    static production() {
        return new AppConfig("https://storage.brij.fi/", "https://orders.brij.fi/", "88tFG8dt9ZacDZb7QP5yiDQeA7sVXvr7XCwZEQSsnCkJ");
    }
    static custom(storageBaseUrl, orderBaseUrl, verifierAuthPk) {
        return new AppConfig(storageBaseUrl, orderBaseUrl, verifierAuthPk);
    }
}
exports.ValidationStatus = void 0;
(function (ValidationStatus) {
    ValidationStatus["Unspecified"] = "UNSPECIFIED";
    ValidationStatus["Pending"] = "PENDING";
    ValidationStatus["Approved"] = "APPROVED";
    ValidationStatus["Rejected"] = "REJECTED";
    ValidationStatus["Unverified"] = "UNVERIFIED";
})(exports.ValidationStatus || (exports.ValidationStatus = {}));
function toValidationStatus(protoStatus) {
    switch (protoStatus) {
        case ValidationStatus.VALIDATION_STATUS_UNSPECIFIED:
            return exports.ValidationStatus.Unspecified;
        case ValidationStatus.VALIDATION_STATUS_PENDING:
            return exports.ValidationStatus.Pending;
        case ValidationStatus.VALIDATION_STATUS_APPROVED:
            return exports.ValidationStatus.Approved;
        case ValidationStatus.VALIDATION_STATUS_REJECTED:
            return exports.ValidationStatus.Rejected;
        default:
            return exports.ValidationStatus.Unspecified;
    }
}
exports.KycStatus = void 0;
(function (KycStatus) {
    KycStatus["Unspecified"] = "KYC_STATUS_UNSPECIFIED";
    KycStatus["Pending"] = "KYC_STATUS_PENDING";
    KycStatus["Approved"] = "KYC_STATUS_APPROVED";
    KycStatus["Rejected"] = "KYC_STATUS_REJECTED";
})(exports.KycStatus || (exports.KycStatus = {}));
class BrijPartnerClient {
    authKeyPair;
    storageBaseUrl;
    orderBaseUrl;
    _authPublicKey;
    _storageClient;
    _orderClient;
    _verifierAuthPk;
    constructor({ authKeyPair, appConfig = AppConfig.demo() }) {
        this.authKeyPair = authKeyPair;
        this.storageBaseUrl = appConfig.storageBaseUrl;
        this.orderBaseUrl = appConfig.orderBaseUrl;
        this._verifierAuthPk = appConfig.verifierAuthPk;
        this._authPublicKey = "";
        this._storageClient = null;
        this._orderClient = null;
    }
    static async generateKeyPair() {
        const keyPair = nacl__default.default.sign.keyPair();
        return {
            publicKey: base58__default.default.encode(keyPair.publicKey),
            privateKey: base58__default.default.encode(keyPair.secretKey),
            secretKey: base58__default.default.encode(keyPair.secretKey),
            seed: base58__default.default.encode(keyPair.secretKey.slice(0, 32)),
            getPublicKeyBytes: async () => keyPair.publicKey,
            getPrivateKeyBytes: async () => keyPair.secretKey,
        };
    }
    static async fromSeed(seed, appConfig) {
        const decoded = base58__default.default.decode(seed);
        const authKeyPair = nacl__default.default.sign.keyPair.fromSeed(decoded);
        const client = new BrijPartnerClient({
            authKeyPair: {
                async getPrivateKeyBytes() {
                    return authKeyPair.secretKey;
                },
                async getPublicKeyBytes() {
                    return authKeyPair.publicKey;
                },
            },
            appConfig,
        });
        await client.init();
        return client;
    }
    async init() {
        await Promise.all([this.generateAuthToken()]);
    }
    async generateAuthToken() {
        const [publicKeyBytes, privateKeyBytes] = await Promise.all([
            this.authKeyPair.getPublicKeyBytes(),
            this.authKeyPair.getPrivateKeyBytes(),
        ]);
        this._authPublicKey = base58__default.default.encode(publicKeyBytes);
        const storageToken = await this.createToken(privateKeyBytes, "storage.brij.fi");
        this._storageClient = axios__default.default.create({
            baseURL: this.storageBaseUrl,
            headers: { Authorization: `Bearer ${storageToken}` },
        });
        const orderToken = await this.createToken(privateKeyBytes, "orders.espressocash.com");
        this._orderClient = axios__default.default.create({
            baseURL: this.orderBaseUrl,
            headers: { Authorization: `Bearer ${orderToken}` },
        });
    }
    async createToken(privateKeyBytes, audience) {
        const header = { alg: "EdDSA", typ: "JWT" };
        const payload = {
            iss: this._authPublicKey,
            iat: Math.floor(Date.now() / 1000),
            aud: audience,
        };
        const encodedHeader = jose.base64url.encode(JSON.stringify(header));
        const encodedPayload = jose.base64url.encode(JSON.stringify(payload));
        const dataToSign = `${encodedHeader}.${encodedPayload}`;
        const signature = nacl__default.default.sign.detached(new TextEncoder().encode(dataToSign), privateKeyBytes);
        return `${dataToSign}.${jose.base64url.encode(signature)}`;
    }
    async getUserData({ userPK, secretKey, includeValues = true }) {
        const response = await this._storageClient.post("/v1/getUserData", {
            userPublicKey: userPK,
            includeValues,
        });
        const responseData = response.data;
        const validationMap = new Map(responseData.validationData.map((data) => [
            data.dataId,
            {
                dataId: data.dataId,
                hash: data.hash,
                status: data.status,
            },
        ]));
        const userData = {};
        const secret = base58__default.default.decode(secretKey);
        for (const encrypted of responseData.userData) {
            const decryptedData = encrypted.encryptedValue?.trim()
                ? await this.decryptData(naclUtil__default.default.decodeBase64(encrypted.encryptedValue), secret)
                : new Uint8Array(0);
            const dataId = encrypted.id;
            const verificationData = validationMap.get(dataId);
            const status = verificationData?.status ?? ValidationStatus.UNRECOGNIZED;
            const commonFields = { dataId, status: toValidationStatus(validationStatusFromJSON(status)) };
            switch (dataTypeFromJSON(encrypted.type)) {
                case DataType.DATA_TYPE_EMAIL: {
                    const data = Email.decode(decryptedData);
                    userData.email = { value: data.value, ...commonFields };
                    break;
                }
                case DataType.DATA_TYPE_NAME: {
                    const data = Name.decode(decryptedData);
                    userData.name = {
                        firstName: data.firstName,
                        lastName: data.lastName,
                        ...commonFields,
                    };
                    break;
                }
                case DataType.DATA_TYPE_BIRTH_DATE: {
                    const data = BirthDate.decode(decryptedData);
                    userData.birthDate = { value: new Date(data.value), ...commonFields };
                    break;
                }
                case DataType.DATA_TYPE_PHONE: {
                    const data = Phone.decode(decryptedData);
                    userData.phone = { value: data.value, ...commonFields };
                    break;
                }
                case DataType.DATA_TYPE_DOCUMENT: {
                    const data = Document.decode(decryptedData);
                    userData.document = {
                        type: documentTypeToJSON(data.type),
                        number: data.number,
                        countryCode: data.countryCode,
                        ...commonFields,
                    };
                    break;
                }
                case DataType.DATA_TYPE_BANK_INFO: {
                    const data = BankInfo.decode(decryptedData);
                    userData.bankInfo = {
                        bankName: data.bankName,
                        accountNumber: data.accountNumber,
                        bankCode: data.bankCode,
                        ...commonFields,
                    };
                    break;
                }
                case DataType.DATA_TYPE_SELFIE_IMAGE: {
                    const data = SelfieImage.decode(decryptedData);
                    userData.selfie = { value: data.value, ...commonFields };
                    break;
                }
            }
        }
        userData.custom = Object.fromEntries(await Promise.all(responseData.customValidationData.map(async (data) => {
            if (!data.encryptedValue) {
                return [data.id, ""];
            }
            const decryptedValue = await this.decryptData(naclUtil__default.default.decodeBase64(data.encryptedValue), secret);
            return [data.id, new TextDecoder().decode(decryptedValue)];
        })));
        return userData;
    }
    async decryptOrderFields(order, secretKey) {
        const decryptField = async (field) => {
            if (!field)
                return "";
            try {
                const encryptedData = naclUtil__default.default.decodeBase64(field);
                return new TextDecoder().decode(await this.decryptData(encryptedData, secretKey));
            }
            catch {
                return field;
            }
        };
        return {
            ...order,
            bankAccount: await decryptField(order.bankAccount),
            bankName: await decryptField(order.bankName),
        };
    }
    async processOrder(order, secretKey) {
        const decryptedOrder = await this.decryptOrderFields(order, secretKey);
        if (order.userSignature) {
            const userVerifyKey = base58__default.default.decode(order.userPublicKey);
            const userMessage = order.type === "ON_RAMP"
                ? this.createUserOnRampMessage({
                    cryptoAmount: order.cryptoAmount,
                    cryptoCurrency: order.cryptoCurrency,
                    fiatAmount: order.fiatAmount,
                    fiatCurrency: order.fiatCurrency,
                })
                : this.createUserOffRampMessage({
                    cryptoAmount: order.cryptoAmount,
                    cryptoCurrency: order.cryptoCurrency,
                    fiatAmount: order.fiatAmount,
                    fiatCurrency: order.fiatCurrency,
                    bankName: decryptedOrder.bankName,
                    bankAccount: decryptedOrder.bankAccount,
                });
            const isValidUserSig = nacl__default.default.sign.detached.verify(new TextEncoder().encode(userMessage), base58__default.default.decode(order.userSignature), userVerifyKey);
            if (!isValidUserSig) {
                throw new Error("Invalid user signature");
            }
        }
        if (order.partnerSignature) {
            const partnerVerifyKey = base58__default.default.decode(order.partnerPublicKey);
            const partnerMessage = order.type === "ON_RAMP"
                ? this.createPartnerOnRampMessage({
                    cryptoAmount: order.cryptoAmount,
                    cryptoCurrency: order.cryptoCurrency,
                    fiatAmount: order.fiatAmount,
                    fiatCurrency: order.fiatCurrency,
                    bankName: decryptedOrder.bankName,
                    bankAccount: decryptedOrder.bankAccount,
                })
                : this.createPartnerOffRampMessage({
                    cryptoAmount: order.cryptoAmount,
                    cryptoCurrency: order.cryptoCurrency,
                    fiatAmount: order.fiatAmount,
                    fiatCurrency: order.fiatCurrency,
                    cryptoWalletAddress: order.cryptoWalletAddress,
                });
            const isValidPartnerSig = nacl__default.default.sign.detached.verify(new TextEncoder().encode(partnerMessage), base58__default.default.decode(order.partnerSignature), partnerVerifyKey);
            if (!isValidPartnerSig) {
                throw new Error("Invalid partner signature");
            }
        }
        return decryptedOrder;
    }
    async getOrder({ externalId, orderId }) {
        const response = await this._orderClient.post("/v1/getOrder", {
            orderId,
            externalId,
        });
        const secretKey = await this.getUserSecretKey(response.data.userPublicKey);
        return this.processOrder(response.data, base58__default.default.decode(secretKey));
    }
    async getPartnerOrders() {
        const response = await this._orderClient.post("/v1/getPartnerOrders");
        return Promise.all(response.data.orders.map(async (order) => {
            const secretKey = await this.getUserSecretKey(order.userPublicKey);
            return this.processOrder(order, base58__default.default.decode(secretKey));
        }));
    }
    async acceptOnRampOrder({ orderId, bankName, bankAccount, externalId, userSecretKey, }) {
        const key = base58__default.default.decode(userSecretKey);
        const order = await this.getOrder({ orderId });
        const encryptField = (value) => {
            const nonce = nacl__default.default.randomBytes(nacl__default.default.secretbox.nonceLength);
            const ciphertext = nacl__default.default.secretbox(naclUtil__default.default.decodeUTF8(value), nonce, key);
            return naclUtil__default.default.encodeBase64(new Uint8Array([...nonce, ...ciphertext]));
        };
        const signatureMessage = this.createPartnerOnRampMessage({
            cryptoAmount: order.cryptoAmount,
            cryptoCurrency: order.cryptoCurrency,
            fiatAmount: order.fiatAmount,
            fiatCurrency: order.fiatCurrency,
            bankName,
            bankAccount,
        });
        const privateKeyBytes = await this.authKeyPair.getPrivateKeyBytes();
        const signature = nacl__default.default.sign.detached(new TextEncoder().encode(signatureMessage), privateKeyBytes);
        await this._orderClient.post("/v1/acceptOrder", {
            orderId,
            bankName: encryptField(bankName),
            bankAccount: encryptField(bankAccount),
            externalId,
            partnerSignature: base58__default.default.encode(signature),
        });
    }
    async acceptOffRampOrder({ orderId, cryptoWalletAddress, externalId }) {
        const order = await this.getOrder({ orderId });
        const signatureMessage = this.createPartnerOffRampMessage({
            cryptoAmount: order.cryptoAmount,
            cryptoCurrency: order.cryptoCurrency,
            fiatAmount: order.fiatAmount,
            fiatCurrency: order.fiatCurrency,
            cryptoWalletAddress,
        });
        const privateKeyBytes = await this.authKeyPair.getPrivateKeyBytes();
        const signature = nacl__default.default.sign.detached(new TextEncoder().encode(signatureMessage), privateKeyBytes);
        await this._orderClient.post("/v1/acceptOrder", {
            orderId,
            cryptoWalletAddress,
            externalId,
            partnerSignature: base58__default.default.encode(signature),
        });
    }
    async completeOnRampOrder({ orderId, transactionId, externalId }) {
        await this._orderClient.post("/v1/completeOrder", {
            orderId: orderId,
            transactionId: transactionId,
            externalId: externalId,
        });
    }
    async completeOffRampOrder({ orderId, externalId }) {
        await this._orderClient.post("/v1/completeOrder", {
            orderId: orderId,
            externalId: externalId,
        });
    }
    async failOrder({ orderId, reason, externalId }) {
        await this._orderClient.post("/v1/failOrder", {
            orderId: orderId,
            reason: reason,
            externalId: externalId,
        });
    }
    async rejectOrder({ orderId, reason }) {
        await this._orderClient.post("/v1/rejectOrder", {
            orderId: orderId,
            reason: reason,
        });
    }
    async getUserInfo(publicKey) {
        const response = await this._storageClient.post("/v1/getInfo", {
            publicKey: publicKey,
        });
        return response.data;
    }
    async getUserSecretKey(publicKey) {
        const info = await this.getUserInfo(publicKey);
        const encryptedData = naclUtil__default.default.decodeBase64(info.encryptedSecretKey);
        const privateKeyBytes = await this.authKeyPair.getPrivateKeyBytes();
        const x25519PrivateKey = ed2curve__default.default.convertSecretKey(privateKeyBytes);
        const userPk = base58__default.default.decode(publicKey);
        const x25519PublicKey = ed2curve__default.default.convertPublicKey(userPk);
        const nonce = encryptedData.slice(0, nacl__default.default.box.nonceLength);
        const ciphertext = encryptedData.slice(nacl__default.default.box.nonceLength);
        const decryptedSecretKey = nacl__default.default.box.open(ciphertext, nonce, x25519PublicKey, x25519PrivateKey);
        if (!decryptedSecretKey) {
            throw new Error("Decryption failed");
        }
        return base58__default.default.encode(decryptedSecretKey);
    }
    async getKycStatusDetails(params) {
        const response = await this._storageClient.post("/v1/getKycStatus", {
            userPublicKey: params.userPK,
            country: params.country,
            validatorPublicKey: this._verifierAuthPk,
        });
        const buffer = response.data.data;
        const uint8Array = naclUtil__default.default.decodeBase64(buffer);
        const decoded = KycItem.decode(uint8Array);
        const kycItem = {
            country: decoded.country,
            status: toKycStatus(decoded.status),
            provider: decoded.provider,
            userPublicKey: decoded.userPublicKey,
            hashes: decoded.hashes,
            additionalData: Object.fromEntries(Object.entries(decoded.additionalData).map(([key, value]) => [
                key,
                new TextDecoder().decode(value)
            ]))
        };
        return {
            status: response.data.status,
            data: kycItem,
            signature: response.data.signature,
        };
    }
    async decryptData(encryptedMessage, key) {
        if (encryptedMessage.length < nacl__default.default.secretbox.nonceLength) {
            throw new Error(`Encrypted message too short: ${encryptedMessage.length} bytes`);
        }
        const nonce = encryptedMessage.slice(0, nacl__default.default.secretbox.nonceLength);
        const ciphertext = encryptedMessage.slice(nacl__default.default.secretbox.nonceLength);
        const decrypted = nacl__default.default.secretbox.open(ciphertext, nonce, key);
        if (!decrypted) {
            throw new Error("Unable to decrypt data");
        }
        return decrypted;
    }
    static currencyDecimals = {
        // Crypto currencies
        USDC: 6,
        SOL: 9,
        // Fiat currencies
        USD: 2,
        NGN: 2,
    };
    convertToDecimalPrecision(amount, currency) {
        const decimals = BrijPartnerClient.currencyDecimals[currency];
        if (decimals === undefined) {
            throw new Error(`Unknown currency: ${currency}`);
        }
        return Math.round(amount * Math.pow(10, decimals)).toString();
    }
    createUserOnRampMessage({ cryptoAmount, cryptoCurrency, fiatAmount, fiatCurrency, }) {
        const decimalCryptoAmount = this.convertToDecimalPrecision(cryptoAmount, cryptoCurrency);
        const decimalFiatAmount = this.convertToDecimalPrecision(fiatAmount, fiatCurrency);
        return `${decimalCryptoAmount}|${cryptoCurrency}|${decimalFiatAmount}|${fiatCurrency}`;
    }
    createUserOffRampMessage({ cryptoAmount, cryptoCurrency, fiatAmount, fiatCurrency, bankName, bankAccount, }) {
        const decimalCryptoAmount = this.convertToDecimalPrecision(cryptoAmount, cryptoCurrency);
        const decimalFiatAmount = this.convertToDecimalPrecision(fiatAmount, fiatCurrency);
        return `${decimalCryptoAmount}|${cryptoCurrency}|${decimalFiatAmount}|${fiatCurrency}|${bankName}|${bankAccount}`;
    }
    createPartnerOnRampMessage({ cryptoAmount, cryptoCurrency, fiatAmount, fiatCurrency, bankName, bankAccount, }) {
        const decimalCryptoAmount = this.convertToDecimalPrecision(cryptoAmount, cryptoCurrency);
        const decimalFiatAmount = this.convertToDecimalPrecision(fiatAmount, fiatCurrency);
        return `${decimalCryptoAmount}|${cryptoCurrency}|${decimalFiatAmount}|${fiatCurrency}|${bankName}|${bankAccount}`;
    }
    createPartnerOffRampMessage({ cryptoAmount, cryptoCurrency, fiatAmount, fiatCurrency, cryptoWalletAddress, }) {
        const decimalCryptoAmount = this.convertToDecimalPrecision(cryptoAmount, cryptoCurrency);
        const decimalFiatAmount = this.convertToDecimalPrecision(fiatAmount, fiatCurrency);
        return `${decimalCryptoAmount}|${cryptoCurrency}|${decimalFiatAmount}|${fiatCurrency}|${cryptoWalletAddress}`;
    }
}
function toKycStatus(protoStatus) {
    switch (protoStatus) {
        case KycStatus.KYC_STATUS_UNSPECIFIED:
            return exports.KycStatus.Unspecified;
        case KycStatus.KYC_STATUS_PENDING:
            return exports.KycStatus.Pending;
        case KycStatus.KYC_STATUS_APPROVED:
            return exports.KycStatus.Approved;
        case KycStatus.KYC_STATUS_REJECTED:
            return exports.KycStatus.Rejected;
        default:
            return exports.KycStatus.Unspecified;
    }
}

exports.AppConfig = AppConfig;
exports.BrijPartnerClient = BrijPartnerClient;
//# sourceMappingURL=index.cjs.map
