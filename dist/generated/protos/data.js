// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.4
//   protoc               v5.26.1
// source: protos/data.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../google/protobuf/timestamp.js";
export const protobufPackage = "brij.storage.v1";
export var DataType;
(function (DataType) {
    DataType[DataType["DATA_TYPE_UNSPECIFIED"] = 0] = "DATA_TYPE_UNSPECIFIED";
    DataType[DataType["DATA_TYPE_PHONE"] = 1] = "DATA_TYPE_PHONE";
    DataType[DataType["DATA_TYPE_EMAIL"] = 2] = "DATA_TYPE_EMAIL";
    DataType[DataType["DATA_TYPE_NAME"] = 3] = "DATA_TYPE_NAME";
    DataType[DataType["DATA_TYPE_BIRTH_DATE"] = 4] = "DATA_TYPE_BIRTH_DATE";
    DataType[DataType["DATA_TYPE_DOCUMENT"] = 5] = "DATA_TYPE_DOCUMENT";
    DataType[DataType["DATA_TYPE_BANK_INFO"] = 6] = "DATA_TYPE_BANK_INFO";
    DataType[DataType["DATA_TYPE_SELFIE_IMAGE"] = 7] = "DATA_TYPE_SELFIE_IMAGE";
    DataType[DataType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DataType || (DataType = {}));
export function dataTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "DATA_TYPE_UNSPECIFIED":
            return DataType.DATA_TYPE_UNSPECIFIED;
        case 1:
        case "DATA_TYPE_PHONE":
            return DataType.DATA_TYPE_PHONE;
        case 2:
        case "DATA_TYPE_EMAIL":
            return DataType.DATA_TYPE_EMAIL;
        case 3:
        case "DATA_TYPE_NAME":
            return DataType.DATA_TYPE_NAME;
        case 4:
        case "DATA_TYPE_BIRTH_DATE":
            return DataType.DATA_TYPE_BIRTH_DATE;
        case 5:
        case "DATA_TYPE_DOCUMENT":
            return DataType.DATA_TYPE_DOCUMENT;
        case 6:
        case "DATA_TYPE_BANK_INFO":
            return DataType.DATA_TYPE_BANK_INFO;
        case 7:
        case "DATA_TYPE_SELFIE_IMAGE":
            return DataType.DATA_TYPE_SELFIE_IMAGE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return DataType.UNRECOGNIZED;
    }
}
export function dataTypeToJSON(object) {
    switch (object) {
        case DataType.DATA_TYPE_UNSPECIFIED:
            return "DATA_TYPE_UNSPECIFIED";
        case DataType.DATA_TYPE_PHONE:
            return "DATA_TYPE_PHONE";
        case DataType.DATA_TYPE_EMAIL:
            return "DATA_TYPE_EMAIL";
        case DataType.DATA_TYPE_NAME:
            return "DATA_TYPE_NAME";
        case DataType.DATA_TYPE_BIRTH_DATE:
            return "DATA_TYPE_BIRTH_DATE";
        case DataType.DATA_TYPE_DOCUMENT:
            return "DATA_TYPE_DOCUMENT";
        case DataType.DATA_TYPE_BANK_INFO:
            return "DATA_TYPE_BANK_INFO";
        case DataType.DATA_TYPE_SELFIE_IMAGE:
            return "DATA_TYPE_SELFIE_IMAGE";
        case DataType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
export var DocumentType;
(function (DocumentType) {
    DocumentType[DocumentType["DOCUMENT_TYPE_UNSPECIFIED"] = 0] = "DOCUMENT_TYPE_UNSPECIFIED";
    DocumentType[DocumentType["DOCUMENT_TYPE_VOTER_ID"] = 1] = "DOCUMENT_TYPE_VOTER_ID";
    DocumentType[DocumentType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DocumentType || (DocumentType = {}));
export function documentTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "DOCUMENT_TYPE_UNSPECIFIED":
            return DocumentType.DOCUMENT_TYPE_UNSPECIFIED;
        case 1:
        case "DOCUMENT_TYPE_VOTER_ID":
            return DocumentType.DOCUMENT_TYPE_VOTER_ID;
        case -1:
        case "UNRECOGNIZED":
        default:
            return DocumentType.UNRECOGNIZED;
    }
}
export function documentTypeToJSON(object) {
    switch (object) {
        case DocumentType.DOCUMENT_TYPE_UNSPECIFIED:
            return "DOCUMENT_TYPE_UNSPECIFIED";
        case DocumentType.DOCUMENT_TYPE_VOTER_ID:
            return "DOCUMENT_TYPE_VOTER_ID";
        case DocumentType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseName() {
    return { firstName: "", lastName: "" };
}
export const Name = {
    encode(message, writer = new BinaryWriter()) {
        if (message.firstName !== "") {
            writer.uint32(10).string(message.firstName);
        }
        if (message.lastName !== "") {
            writer.uint32(18).string(message.lastName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseName();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.firstName = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.lastName = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
            lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.firstName !== "") {
            obj.firstName = message.firstName;
        }
        if (message.lastName !== "") {
            obj.lastName = message.lastName;
        }
        return obj;
    },
    create(base) {
        return Name.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseName();
        message.firstName = object.firstName ?? "";
        message.lastName = object.lastName ?? "";
        return message;
    },
};
function createBaseBirthDate() {
    return { value: undefined };
}
export const BirthDate = {
    encode(message, writer = new BinaryWriter()) {
        if (message.value !== undefined) {
            Timestamp.encode(toTimestamp(message.value), writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBirthDate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.value = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { value: isSet(object.value) ? fromJsonTimestamp(object.value) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.value !== undefined) {
            obj.value = message.value.toISOString();
        }
        return obj;
    },
    create(base) {
        return BirthDate.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBirthDate();
        message.value = object.value ?? undefined;
        return message;
    },
};
function createBaseDocument() {
    return { type: 0, number: "", countryCode: "" };
}
export const Document = {
    encode(message, writer = new BinaryWriter()) {
        if (message.type !== 0) {
            writer.uint32(8).int32(message.type);
        }
        if (message.number !== "") {
            writer.uint32(18).string(message.number);
        }
        if (message.countryCode !== "") {
            writer.uint32(26).string(message.countryCode);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDocument();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.type = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.number = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.countryCode = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet(object.type) ? documentTypeFromJSON(object.type) : 0,
            number: isSet(object.number) ? globalThis.String(object.number) : "",
            countryCode: isSet(object.countryCode) ? globalThis.String(object.countryCode) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.type !== 0) {
            obj.type = documentTypeToJSON(message.type);
        }
        if (message.number !== "") {
            obj.number = message.number;
        }
        if (message.countryCode !== "") {
            obj.countryCode = message.countryCode;
        }
        return obj;
    },
    create(base) {
        return Document.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDocument();
        message.type = object.type ?? 0;
        message.number = object.number ?? "";
        message.countryCode = object.countryCode ?? "";
        return message;
    },
};
function createBaseBankInfo() {
    return { accountNumber: "", bankCode: "", bankName: "" };
}
export const BankInfo = {
    encode(message, writer = new BinaryWriter()) {
        if (message.accountNumber !== "") {
            writer.uint32(10).string(message.accountNumber);
        }
        if (message.bankCode !== "") {
            writer.uint32(18).string(message.bankCode);
        }
        if (message.bankName !== "") {
            writer.uint32(26).string(message.bankName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBankInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.accountNumber = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.bankCode = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.bankName = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            accountNumber: isSet(object.accountNumber) ? globalThis.String(object.accountNumber) : "",
            bankCode: isSet(object.bankCode) ? globalThis.String(object.bankCode) : "",
            bankName: isSet(object.bankName) ? globalThis.String(object.bankName) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.accountNumber !== "") {
            obj.accountNumber = message.accountNumber;
        }
        if (message.bankCode !== "") {
            obj.bankCode = message.bankCode;
        }
        if (message.bankName !== "") {
            obj.bankName = message.bankName;
        }
        return obj;
    },
    create(base) {
        return BankInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBankInfo();
        message.accountNumber = object.accountNumber ?? "";
        message.bankCode = object.bankCode ?? "";
        message.bankName = object.bankName ?? "";
        return message;
    },
};
function createBaseEmail() {
    return { value: "" };
}
export const Email = {
    encode(message, writer = new BinaryWriter()) {
        if (message.value !== "") {
            writer.uint32(10).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEmail();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return Email.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseEmail();
        message.value = object.value ?? "";
        return message;
    },
};
function createBaseSelfieImage() {
    return { value: new Uint8Array(0) };
}
export const SelfieImage = {
    encode(message, writer = new BinaryWriter()) {
        if (message.value.length !== 0) {
            writer.uint32(10).bytes(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSelfieImage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.value = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0) };
    },
    toJSON(message) {
        const obj = {};
        if (message.value.length !== 0) {
            obj.value = base64FromBytes(message.value);
        }
        return obj;
    },
    create(base) {
        return SelfieImage.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSelfieImage();
        message.value = object.value ?? new Uint8Array(0);
        return message;
    },
};
function createBasePhone() {
    return { value: "" };
}
export const Phone = {
    encode(message, writer = new BinaryWriter()) {
        if (message.value !== "") {
            writer.uint32(10).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePhone();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return Phone.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePhone();
        message.value = object.value ?? "";
        return message;
    },
};
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function toTimestamp(date) {
    const seconds = Math.trunc(date.getTime() / 1_000);
    const nanos = (date.getTime() % 1_000) * 1_000_000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (t.seconds || 0) * 1_000;
    millis += (t.nanos || 0) / 1_000_000;
    return new globalThis.Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof globalThis.Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new globalThis.Date(o);
    }
    else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=data.js.map